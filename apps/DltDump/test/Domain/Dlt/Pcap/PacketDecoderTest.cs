namespace RJCP.App.DltDump.Domain.Dlt.Pcap
{
    using System;
    using System.Collections.Generic;
    using Infrastructure;
    using NUnit.Framework;
    using RJCP.Diagnostics.Log;
    using RJCP.Diagnostics.Log.Decoder;
    using RJCP.Diagnostics.Log.Dlt;
    using RJCP.Diagnostics.Log.Dlt.Args;

    [TestFixture]
    public class PacketDecoderTest
    {
        private static readonly ITraceDecoderFactory<DltTraceLineBase> DefaultPcapFactory = new PcapTraceDecoderFactory();

        private static readonly DateTime Time1 = new DateTime(2022, 4, 24, 17, 2, 54, DateTimeKind.Utc).AddMilliseconds(580);
        private static readonly DateTime Time2 = new DateTime(2022, 4, 24, 17, 2, 55, DateTimeKind.Utc).AddMilliseconds(20);
        private static readonly DateTime Time3 = new DateTime(2022, 4, 24, 17, 2, 55, DateTimeKind.Utc).AddMilliseconds(620);

        private static readonly DateTime Time1b = Time1.AddMilliseconds(10);
        private static readonly DateTime Time2b = Time2.AddMilliseconds(10);
        private static readonly DateTime Time3b = Time3.AddMilliseconds(10);

        [Test]
        public void UnknownLinkType()
        {
            Assert.That(() => {
                _ = new PacketDecoder(LinkTypes.LINKTYPE_NULL, DefaultPcapFactory);
            }, Throws.TypeOf<UnknownPcapFileFormatException>());
        }

        [Test]
        public void DecodeEthernetPacket()
        {
            byte[] packet = {
                0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
                0x08, 0x00,                                                             // IPv4 Proto
                0x45, 0x00, 0x00, 0x57, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x65, // IPv4 Header
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x43, 0xB5, 0xCF,                         // UDP Header
                0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, // DLT
                0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
                0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
                0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73,
                0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0x2E, 0x00
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                IList<DltTraceLineBase> lines = new List<DltTraceLineBase>(
                    packetDecoder.DecodePacket(packet, Time1, 20));
                Assert.That(lines, Has.Count.EqualTo(1));
                Assert.That(lines[0].Text, Is.EqualTo("DLT Argument test string.."));
                Assert.That(lines[0].TimeStamp, Is.EqualTo(Time1));
            }
        }

        [Test]
        public void DecodeEthernetPacketVlan73()
        {
            byte[] packet = {
                0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
                0x81, 0x00, 0x00, 0x49, 0x08, 0x00,                                     // 802.1q, IPv4 Proto
                0x45, 0x00, 0x00, 0x57, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x65, // IPv4 Header
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x43, 0xB5, 0xCF,                         // UDP Header
                0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, // DLT
                0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
                0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
                0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73,
                0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0x2E, 0x00
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                IList<DltTraceLineBase> lines = new List<DltTraceLineBase>(
                    packetDecoder.DecodePacket(packet, Time1, 20));
                Assert.That(lines, Has.Count.EqualTo(1));
                Assert.That(lines[0].Text, Is.EqualTo("DLT Argument test string.."));
                Assert.That(lines[0].TimeStamp, Is.EqualTo(Time1));
            }
        }

        [Test]
        public void DecodeLinuxSllPacket()
        {
            byte[] packet = {
                0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // SLL Header
                0x00, 0x00,
                0x08, 0x00,                                                             // IPv4 Proto
                0x45, 0x00, 0x00, 0x57, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x65, // IPv4 Header
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x43, 0xB5, 0xCF,                         // UDP Header
                0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, // DLT
                0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
                0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
                0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73,
                0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0x2E, 0x00
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_LINUX_SLL, DefaultPcapFactory)) {
                IList<DltTraceLineBase> lines = new List<DltTraceLineBase>(
                    packetDecoder.DecodePacket(packet, Time1, 20));
                Assert.That(lines, Has.Count.EqualTo(1));
                Assert.That(lines[0].Text, Is.EqualTo("DLT Argument test string.."));
                Assert.That(lines[0].TimeStamp, Is.EqualTo(Time1));
            }
        }

        [Test]
        public void DecodeLinuxSllPacket73()
        {
            byte[] packet = {
                0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // SLL Header
                0x00, 0x00,
                0x81, 0x00, 0x00, 0x49, 0x08, 0x00,                                     // 802.1q, IPv4 Proto
                0x45, 0x00, 0x00, 0x57, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x65, // IPv4 Header
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x43, 0xB5, 0xCF,                         // UDP Header
                0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, // DLT
                0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
                0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
                0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73,
                0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0x2E, 0x00
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_LINUX_SLL, DefaultPcapFactory)) {
                IList<DltTraceLineBase> lines = new List<DltTraceLineBase>(
                    packetDecoder.DecodePacket(packet, Time1, 20));
                Assert.That(lines, Has.Count.EqualTo(1));
                Assert.That(lines[0].Text, Is.EqualTo("DLT Argument test string.."));
                Assert.That(lines[0].TimeStamp, Is.EqualTo(Time1));
            }
        }

        [Test]
        public void DecodeMultipleDltInPacket()
        {
            byte[] packet = {
                0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
                0x08, 0x00,                                                             // IPv4 Proto
                0x45, 0x00, 0x00, 0x92, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x2A, // IPv4 Header
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x7E, 0x69, 0x15,                         // UDP Header
                0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, // DLT
                0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
                0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
                0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73,
                0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0x2E, 0x00,
                0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, // DLT
                0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
                0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
                0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73,
                0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x32, 0x00
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                IList<DltTraceLineBase> lines = new List<DltTraceLineBase>(
                    packetDecoder.DecodePacket(packet, Time1, 20));
                Assert.That(lines, Has.Count.EqualTo(2));
                Assert.That(lines[0].Text, Is.EqualTo("DLT Argument test string.."));
                Assert.That(lines[0].TimeStamp, Is.EqualTo(Time1));
                Assert.That(lines[1].Text, Is.EqualTo("DLT Argument test string 2"));
                Assert.That(lines[1].TimeStamp, Is.EqualTo(Time1));
            }
        }

        [Test]
        public void IgnoreArpEthernetPacket()
        {
            // Don't decode anything that is not IPv4.

            byte[] packet = {
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x25, 0x36, 0x66, 0x74, 0x66, // DstMac, SrcMac
                0x08, 0x06,
                0x00, 0x01, 0x08, 0x00, 0x06, 0x04, 0x00, 0x01, 0x00, 0x25, 0x36, 0x66, // ARP
                0x74, 0x66, 0xC0, 0xA8, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0xC0, 0xA8, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                IEnumerable<DltTraceLineBase> lines = packetDecoder.DecodePacket(packet, DateTime.UtcNow, 20);
                Assert.That(lines, Is.Empty);
            }
        }

        [Test]
        public void IgnoreArpDllPacket()
        {
            // Don't decode anything that is not IPv4.

            byte[] packet = {
                0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // SLL Header
                0x00, 0x00,
                0x08, 0x06,
                0x00, 0x01, 0x08, 0x00, 0x06, 0x04, 0x00, 0x01, 0x00, 0x25, 0x36, 0x66, // ARP
                0x74, 0x66, 0xC0, 0xA8, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0xC0, 0xA8, 0x01, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_LINUX_SLL, DefaultPcapFactory)) {
                IEnumerable<DltTraceLineBase> lines = packetDecoder.DecodePacket(packet, DateTime.UtcNow, 20);
                Assert.That(lines, Is.Empty);
            }
        }

        [Test]
        public void MinimalDltNonVerbosePacketEthernet()
        {
            byte[] packet = {
                0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
                0x08, 0x00,                                                             // IPv4 Proto
                0x45, 0x00, 0x00, 0x24, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x98, // IPv4 Header
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x10, 0xE7, 0x74,                         // UDP Header
                0x20, 0x01, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00                          // DLT
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                IList<DltTraceLineBase> lines = new List<DltTraceLineBase>(
                    packetDecoder.DecodePacket(packet, Time1, 20));
                Assert.That(lines, Has.Count.EqualTo(1));
                Assert.That(lines[0].TimeStamp, Is.EqualTo(Time1));
                Assert.That(lines[0].Features.IsVerbose, Is.False);
                Assert.That(((DltNonVerboseTraceLine)lines[0]).MessageId, Is.EqualTo(1));

                IList<IDltArg> args = ((DltNonVerboseTraceLine)lines[0]).Arguments;
                Assert.That(args, Has.Count.EqualTo(1));
            }
        }

        [Test]
        public void MinimalDltNonVerbosePacketSll()
        {
            byte[] packet = {
                0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // SLL Header
                0x00, 0x00,
                0x08, 0x00,                                                             // IPv4 Proto
                0x45, 0x00, 0x00, 0x24, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x98, // IPv4 Header
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x10, 0xE7, 0x74,                         // UDP Header
                0x20, 0x01, 0x00, 0x08, 0x01, 0x00, 0x00, 0x00                          // DLT
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_LINUX_SLL, DefaultPcapFactory)) {
                IList<DltTraceLineBase> lines = new List<DltTraceLineBase>(
                    packetDecoder.DecodePacket(packet, Time1, 20));
                Assert.That(lines, Has.Count.EqualTo(1));
                Assert.That(lines[0].TimeStamp, Is.EqualTo(Time1));
                Assert.That(lines[0].Features.IsVerbose, Is.False);
                Assert.That(((DltNonVerboseTraceLine)lines[0]).MessageId, Is.EqualTo(1));

                IList<IDltArg> args = ((DltNonVerboseTraceLine)lines[0]).Arguments;
                Assert.That(args, Has.Count.EqualTo(1));
            }
        }

        [Test]
        public void TooSmallDltNonVerbosePacketEthernet()
        {
            byte[] packet = {
                0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
                0x08, 0x00,                                                             // IPv4 Proto
                0x45, 0x00, 0x00, 0x24, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x98, // IPv4 Header
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x10, 0xE7, 0x74,                         // UDP Header
                0x20, 0x01, 0x00, 0x04                                                  // DLT, incomplete
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                IEnumerable<DltTraceLineBase> lines = packetDecoder.DecodePacket(packet, DateTime.UtcNow, 20);
                Assert.That(lines, Is.Empty);
            }
        }

        [Test]
        public void TooSmallDltNonVerbosePacketSll()
        {
            byte[] packet = {
                0x00, 0x04, 0x00, 0x01, 0x00, 0x06, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // SLL Header
                0x00, 0x00,
                0x08, 0x00,                                                             // IPv4 Proto
                0x45, 0x00, 0x00, 0x24, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x98, // IPv4 Header
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x10, 0xE7, 0x74,                         // UDP Header
                0x20, 0x01, 0x00, 0x04,                                                 // DLT
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_LINUX_SLL, DefaultPcapFactory)) {
                IEnumerable<DltTraceLineBase> lines = packetDecoder.DecodePacket(packet, DateTime.UtcNow, 20);
                Assert.That(lines, Is.Empty);
            }
        }

        [Test]
        public void DecodeEthernetPacketPort65000()
        {
            byte[] packet = {
                0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
                0x08, 0x00,                                                             // IPv4 Proto
                0x45, 0x00, 0x00, 0x57, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x65, // IPv4 Header
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x0D, 0xA2, 0xFD, 0xE8, 0x00, 0x43, 0xB5, 0xCF,                         // UDP Header, dest 65000
                0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, // DLT
                0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
                0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
                0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73,
                0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0x2E, 0x00
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                IEnumerable<DltTraceLineBase> lines = packetDecoder.DecodePacket(packet, DateTime.UtcNow, 20);
                Assert.That(lines, Is.Empty);
            }
        }

        [Test]
        public void CutFrame()
        {
            // Same data from test DecodeEthernetPacket
            byte[] packet = {
                0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
                0x08, 0x00,                                                             // IPv4 Proto
                0x45, 0x00, 0x00, 0x57, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x65, // IPv4 Header
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x43, 0xB5, 0xCF,                         // UDP Header
                0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, // DLT
                0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
                0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
                0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73,
                0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0x2E, 0x00
            };

            // We should not end up with any crashes.
            for (int packetLen = 0; packetLen < packet.Length - 1; packetLen++) {
                using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                    IEnumerable<DltTraceLineBase> lines =
                        packetDecoder.DecodePacket(packet.AsSpan(0, packetLen), DateTime.UtcNow, 20);
                    Assert.That(lines, Is.Empty);
                }
            }
        }

        [Test]
        public void NotUdpProtocol()
        {
            byte[] packet = {
                0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
                0x08, 0x00,                                                             // IPv4 Proto
                0x45, 0x00, 0x00, 0x57, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x12, 0xA3, 0x65, // IPv4 Header, Proto=0x12 (not UDP)
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x43, 0xB5, 0xCF,
                0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E,
                0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
                0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
                0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73,
                0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0x2E, 0x00
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                IEnumerable<DltTraceLineBase> lines = packetDecoder.DecodePacket(packet, DateTime.UtcNow, 20);
                Assert.That(lines, Is.Empty);
            }
        }

        [Test]
        public void NotIPv4Version()
        {
            byte[] packet = {
                0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
                0x08, 0x00,                                                             // IPv4 Proto
                0x55, 0x00, 0x00, 0x57, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x65, // IPv5 header
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x43, 0xB5, 0xCF,
                0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E,
                0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
                0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
                0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73,
                0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0x2E, 0x00
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                IEnumerable<DltTraceLineBase> lines = packetDecoder.DecodePacket(packet, DateTime.UtcNow, 20);
                Assert.That(lines, Is.Empty);
            }
        }

        [Test]
        public void DecodeMultipleDltInPacketFirstInvalidSkipped()
        {
            byte[] packet = {
                0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
                0x08, 0x00,                                                             // IPv4 Proto
                0x45, 0x00, 0x00, 0x92, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x2A, // IPv4 Header
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x7E, 0x69, 0x15,                         // UDP Header
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // DLT
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, // DLT
                0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
                0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
                0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73,
                0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x20, 0x32, 0x00
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                IList<DltTraceLineBase> lines =
                    new List<DltTraceLineBase>(packetDecoder.DecodePacket(packet, Time1, 20));
                Assert.That(lines, Has.Count.EqualTo(2));
                Assert.That(lines[0].Text, Is.EqualTo("Skipped: 59 bytes; Reason: Invalid packet standard header"));
                Assert.That(lines[0].TimeStamp, Is.EqualTo(Time1));
                Assert.That(lines[1].Text, Is.EqualTo("DLT Argument test string 2"));
                Assert.That(lines[1].TimeStamp, Is.EqualTo(Time1));
            }
        }

        private static readonly byte[] FragFrame1 = {
            0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
            0x08, 0x00,                                                             // IPv4 Proto
            0x45, 0x00, 0x00, 0x5C, 0x3A, 0x25, 0x20, 0x00, 0x01, 0x11, 0x83, 0x60, // IPv4 Header (id=0x3a25, MF=1)
            0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
            0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x7E, 0x69, 0x15,                         // UDP Header (length=126)
            0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, // DLT
            0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
            0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
            0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73,
            0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0x2E, 0x00,
            0x3D, 0x0B, 0x00, 0x3B, 0x45                                            // DLT
        };

        private static readonly byte[] FragFrame2 = {
            0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
            0x08, 0x00,                                                             // IPv4 Proto
            0x45, 0x00, 0x00, 0x4A, 0x3A, 0x25, 0x00, 0x09, 0x01, 0x11, 0xA3, 0x69, // IPv4 Header (id=0x3a25, MF=0, Offset=9*8=72)
            0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
            0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, 0x00, 0x01, 0x54, 0x4A, 0x41, // DLT (ctd.)
            0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54, 0x58, 0x31, 0x00, 0x02, 0x00,
            0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20, 0x41, 0x72, 0x67, 0x75, 0x6D,
            0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x73, 0x74, 0x72,
            0x69, 0x6E, 0x67, 0x20, 0x32, 0x00
        };

        private static readonly byte[] MiniFragFrame1 = {
            0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
            0x08, 0x00,                                                             // IPv4 Proto
            0x45, 0x00, 0x00, 0x44, 0x4A, 0x25, 0x20, 0x00, 0x01, 0x11, 0x83, 0x60, // IPv4 Header (id=0x4a25, MF=1)
            0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
            0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x7E, 0x69, 0x15,                         // UDP Header (length=126)
            0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, // DLT
            0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
            0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
            0x41, 0x72, 0x67, 0x75
        };

        private static readonly byte[] MiniFragFrame2 = {
            0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
            0x08, 0x00,                                                             // IPv4 Proto
            0x45, 0x00, 0x00, 0x44, 0x4A, 0x25, 0x20, 0x06, 0x01, 0x11, 0x83, 0x60, // IPv4 Header (id=0x4a25, MF=1)
            0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
            0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x73, 0x74, // DLT (ctd.)
            0x72, 0x69, 0x6E, 0x67, 0x2E, 0x2E, 0x00,
            0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, // DLT
            0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
            0x58, 0x31, 0x00, 0x02, 0x00
        };

        private static readonly byte[] MiniFragFrame3 = {
            0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
            0x08, 0x00,                                                             // IPv4 Proto
            0x45, 0x00, 0x00, 0x32, 0x4A, 0x25, 0x00, 0x0C, 0x01, 0x11, 0x83, 0x60, // IPv4 Header (id=0x4a25, MF=0)
            0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
            0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20, 0x41, 0x72, 0x67, 0x75, 0x6D,
            0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x73, 0x74, 0x72,
            0x69, 0x6E, 0x67, 0x20, 0x32, 0x00
        };

        [Test]
        public void ReassembleIpFragmentInOrder()
        {
            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                Assert.That(packetDecoder.DecodePacket(FragFrame1, Time1, 40), Is.Empty);
                IList<DltTraceLineBase> lines =
                    new List<DltTraceLineBase>(packetDecoder.DecodePacket(FragFrame2, Time2, 162));

                Assert.That(lines, Has.Count.EqualTo(2));
                Assert.That(lines[0].Text, Is.EqualTo("DLT Argument test string.."));
                Assert.That(lines[0].TimeStamp, Is.EqualTo(Time1));
                Assert.That(lines[0].Position, Is.EqualTo(82));  // Offset 42 in first frame
                Assert.That(lines[1].Text, Is.EqualTo("DLT Argument test string 2"));
                Assert.That(lines[1].TimeStamp, Is.EqualTo(Time1));
                Assert.That(lines[1].Position, Is.EqualTo(141)); // Offset 101 in first frame
            }
        }

        [Test]
        public void ReassembleIpFragmentInReverse()
        {
            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                Assert.That(packetDecoder.DecodePacket(FragFrame2, Time1, 40), Is.Empty);
                IList<DltTraceLineBase> lines =
                    new List<DltTraceLineBase>(packetDecoder.DecodePacket(FragFrame1, Time2, 180));

                Assert.That(lines, Has.Count.EqualTo(2));
                Assert.That(lines[0].Text, Is.EqualTo("DLT Argument test string.."));
                Assert.That(lines[0].TimeStamp, Is.EqualTo(Time2));
                Assert.That(lines[0].Position, Is.EqualTo(222));  // Offset 42 in 2nd frame
                Assert.That(lines[1].Text, Is.EqualTo("DLT Argument test string 2"));
                Assert.That(lines[1].TimeStamp, Is.EqualTo(Time2));
                Assert.That(lines[1].Position, Is.EqualTo(281)); // Offset 101 in 2nd frame
            }
        }

        [Test]
        public void ReassembleIpFragmentWrongPort()
        {
            byte[] frame1 = FragFrame1.CopyArray();
            frame1[35] = 0xFF; frame1[37] = 0xFF;        // Change ports

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                Assert.That(packetDecoder.DecodePacket(frame1, Time1, 40), Is.Empty);
                IList<DltTraceLineBase> lines =
                    new List<DltTraceLineBase>(packetDecoder.DecodePacket(FragFrame2, Time2, 162));

                // The port is wrong. Manually check with the debugger there are no fragments.
                Assert.That(lines, Is.Empty);
            }
        }

        [Test]
        public void ReassembleIpFragmentsUdpTruncated()
        {
            byte[] frame1 = FragFrame1.CopyArray();
            frame1[39] += 1;   // Increase UDP length by 1, make it look truncated.

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                Assert.That(packetDecoder.DecodePacket(frame1, Time1, 40), Is.Empty);
                IList<DltTraceLineBase> lines =
                    new List<DltTraceLineBase>(packetDecoder.DecodePacket(FragFrame2, Time2, 162));

                // The port is wrong. Manually check with the debugger there are no fragments.
                Assert.That(lines, Is.Empty);
            }
        }

        [Test]
        public void ReassemblyIpFragmentFrame1Repeated()
        {
            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                Assert.That(packetDecoder.DecodePacket(FragFrame1, Time1, 40), Is.Empty);

                // This packet will be ignored. Internally, it is seen as a duplicate fragment.
                Assert.That(packetDecoder.DecodePacket(FragFrame1, Time1, 140), Is.Empty);
                IList<DltTraceLineBase> lines =
                    new List<DltTraceLineBase>(packetDecoder.DecodePacket(FragFrame2, Time2, 262));

                Assert.That(lines, Has.Count.EqualTo(2));
                Assert.That(lines[0].Text, Is.EqualTo("DLT Argument test string.."));
                Assert.That(lines[0].TimeStamp, Is.EqualTo(Time1));
                Assert.That(lines[0].Position, Is.EqualTo(82));  // Offset 42 in first packet.
                Assert.That(lines[1].Text, Is.EqualTo("DLT Argument test string 2"));
                Assert.That(lines[1].TimeStamp, Is.EqualTo(Time1));
                Assert.That(lines[1].Position, Is.EqualTo(141)); // Offset 101 in first frame.
            }
        }

        [Test]
        public void Reassemble3IpFragmentInOrder()
        {
            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                Assert.That(packetDecoder.DecodePacket(MiniFragFrame1, Time1, 0), Is.Empty);
                Assert.That(packetDecoder.DecodePacket(MiniFragFrame2, Time2, 100), Is.Empty);
                IList<DltTraceLineBase> lines =
                    new List<DltTraceLineBase>(packetDecoder.DecodePacket(MiniFragFrame3, Time3, 200));

                Assert.That(lines, Has.Count.EqualTo(2));
                Assert.That(lines[0].Text, Is.EqualTo("DLT Argument test string.."));
                Assert.That(lines[0].TimeStamp, Is.EqualTo(Time1));
                Assert.That(lines[0].Position, Is.EqualTo(42));  // Offset 42 in first frame
                Assert.That(lines[1].Text, Is.EqualTo("DLT Argument test string 2"));
                // Even though in the second packet, the time from the first packet (fragmentation offset is zero) is
                // used.
                Assert.That(lines[1].TimeStamp, Is.EqualTo(Time1));
                Assert.That(lines[1].Position, Is.EqualTo(153)); // Offset 53 in second frame
            }
        }

        [Test]
        public void Reassemble3IpFragmentReverseOrder()
        {
            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                Assert.That(packetDecoder.DecodePacket(MiniFragFrame3, Time1, 0), Is.Empty);
                Assert.That(packetDecoder.DecodePacket(MiniFragFrame2, Time2, 100), Is.Empty);
                IList<DltTraceLineBase> lines =
                    new List<DltTraceLineBase>(packetDecoder.DecodePacket(MiniFragFrame1, Time3, 200));

                Assert.That(lines, Has.Count.EqualTo(2));
                Assert.That(lines[0].Text, Is.EqualTo("DLT Argument test string.."));
                Assert.That(lines[0].TimeStamp, Is.EqualTo(Time3));
                Assert.That(lines[0].Position, Is.EqualTo(242));  // Offset 42 in first frame
                Assert.That(lines[1].Text, Is.EqualTo("DLT Argument test string 2"));
                // Even though in the second packet, the time from the first packet (fragmentation offset is zero) is
                // used.
                Assert.That(lines[1].TimeStamp, Is.EqualTo(Time3));
                Assert.That(lines[1].Position, Is.EqualTo(153)); // Offset 53 in second frame
            }
        }

        [Test]
        public void Reassemble3IpFragmentReverseOrderDuplicated()
        {
            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                Assert.That(packetDecoder.DecodePacket(MiniFragFrame3, Time1, 0), Is.Empty);
                Assert.That(packetDecoder.DecodePacket(MiniFragFrame3, Time1b, 100), Is.Empty);
                Assert.That(packetDecoder.DecodePacket(MiniFragFrame2, Time2, 200), Is.Empty);
                Assert.That(packetDecoder.DecodePacket(MiniFragFrame2, Time2b, 300), Is.Empty);
                IList<DltTraceLineBase> lines =
                    new List<DltTraceLineBase>(packetDecoder.DecodePacket(MiniFragFrame1, Time3, 400));
                Assert.That(packetDecoder.DecodePacket(MiniFragFrame1, Time3b, 500), Is.Empty);

                Assert.That(lines, Has.Count.EqualTo(2));
                Assert.That(lines[0].Text, Is.EqualTo("DLT Argument test string.."));
                Assert.That(lines[0].TimeStamp, Is.EqualTo(Time3));
                Assert.That(lines[0].Position, Is.EqualTo(442));  // Offset 42 in first frame
                Assert.That(lines[1].Text, Is.EqualTo("DLT Argument test string 2"));

                // Even though in the second packet, the time from the first packet (fragmentation offset is zero) is
                // used.
                Assert.That(lines[1].TimeStamp, Is.EqualTo(Time3));
                Assert.That(lines[1].Position, Is.EqualTo(253)); // Offset 53 in second frame
            }
        }

        private static readonly int[] InternetHeaders = {
            0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F
        };

        [TestCaseSource(nameof(InternetHeaders))]
        public void LargeInternetHeaderCutUntagged(int ih)
        {
            // Ensure that the header is more than 50 bytes (the minimum size), and that we don't have the UDP
            // port to ensure buffer size checks are made.

            byte[] packet = new byte[50] {
                0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
                0x08, 0x00,                                                             // IPv4 Proto
                0x49, 0x00, 0x00, 0x67, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x65, // IPv4 Header, IHL=36 bytes
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00
            };

            packet[14] = (byte)ih;
            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                IEnumerable<DltTraceLineBase> lines = packetDecoder.DecodePacket(packet, DateTime.UtcNow, 20);
                Assert.That(lines, Is.Empty);
            }
        }

        [TestCaseSource(nameof(InternetHeaders))]
        public void LargeInternetHeaderCutTagged(int ih)
        {
            // Ensure that the header is more than 52 bytes (the minimum size), and that we don't have the UDP
            // port to ensure buffer size checks are made.

            byte[] packet = new byte[50] {
                0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
                0x81, 0x00, 0x00, 0x49, 0x08, 0x00,                                     // IPv4 Proto
                0x48, 0x00, 0x00, 0x67, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x65, // IPv4 Header, IHL=36 bytes
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            };

            packet[18] = (byte)ih;
            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                IEnumerable<DltTraceLineBase> lines = packetDecoder.DecodePacket(packet, DateTime.UtcNow, 20);
                Assert.That(lines, Is.Empty);
            }
        }

        [Test]
        public void Ipv4CorruptHeaderLengthZeroLength()
        {
            byte[] packet = {
                0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
                0x08, 0x00,                                                             // IPv4 Proto
                0x45, 0x00, 0x00, 0x00, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x65, // IPv4 Header
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x43, 0xB5, 0xCF,                         // UDP Header
                0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, // DLT
                0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
                0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
                0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73,
                0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0x2E, 0x00
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                IEnumerable<DltTraceLineBase> lines = packetDecoder.DecodePacket(packet, DateTime.UtcNow, 20);
                Assert.That(lines, Is.Empty);
            }
        }

        [Test]
        public void Ipv4HeaderLengthLargeCutPacket()
        {
            byte[] packet = {
                0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
                0x08, 0x00,                                                             // IPv4 Proto
                0x45, 0x00, 0x00, 0x57, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x65, // IPv4 Header
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x43, 0xB5, 0xCF,                         // UDP Header
                0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, // DLT
                0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
                0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
                0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73,
                0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0x2E // , 0x00
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                IEnumerable<DltTraceLineBase> lines = packetDecoder.DecodePacket(packet, DateTime.UtcNow, 20);
                Assert.That(lines, Is.Empty);
            }
        }

        [Test]
        public void Ipv4HeaderLengthSmall()
        {
            // The IP Header is 60 bytes (0x4F) and total length is 48 bytes.
            byte[] packet = {
                0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
                0x08, 0x00,                                                             // IPv4 Proto
                0x4F, 0x00, 0x00, 0x30, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x65, // IPv4 Header
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                IEnumerable<DltTraceLineBase> lines = packetDecoder.DecodePacket(packet, DateTime.UtcNow, 20);
                Assert.That(lines, Is.Empty);
            }
        }

        [Test]
        public void IPv4UdpLengthBad()
        {
            byte[] packet = {
                0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
                0x08, 0x00,                                                             // IPv4 Proto
                0x45, 0x00, 0x00, 0x57, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x65, // IPv4 Header
                0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
                0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x44, 0xB5, 0xCF,                         // UDP Header
                0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, // DLT
                0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
                0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
                0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73,
                0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0x2E, 0x00
            };

            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                IEnumerable<DltTraceLineBase> lines = packetDecoder.DecodePacket(packet, DateTime.UtcNow, 20);
                Assert.That(lines, Is.Empty);
            }
        }

        private static readonly byte[] P1a = {
            0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
            0x08, 0x00,                                                             // IPv4 Proto
            0x45, 0x00, 0x00, 0x34, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x65, // IPv4 Header
            0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
            0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x20, 0xB5, 0xCF,                         // UDP Header
            0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, // DLT
            0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
        };

        private static readonly byte[] P1b = {
            0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
            0x08, 0x00,                                                             // IPv4 Proto
            0x45, 0x00, 0x00, 0x3F, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x65, // IPv4 Header
            0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
            0x0D, 0xA2, 0x0D, 0xA2, 0x00, 0x2B, 0xB5, 0xCF,                         // UDP Header
            0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
            0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73,
            0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x2E, 0x2E, 0x00
        };

        private static readonly byte[] P2a = {
            0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
            0x08, 0x00,                                                             // IPv4 Proto
            0x45, 0x00, 0x00, 0x34, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x65, // IPv4 Header
            0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
            0x0D, 0xA3, 0x0D, 0xA2, 0x00, 0x20, 0xB5, 0xCF,                         // UDP Header
            0x3D, 0x0B, 0x00, 0x3B, 0x45, 0x43, 0x55, 0x31, 0x00, 0x00, 0x03, 0x8E, // DLT
            0x00, 0x01, 0x54, 0x4A, 0x41, 0x01, 0x41, 0x50, 0x50, 0x31, 0x43, 0x54,
        };

        private static readonly byte[] P2b = {
            0x10, 0xDF, 0x23, 0x41, 0xE4, 0xC2, 0x74, 0xE7, 0xB1, 0x14, 0x44, 0x5E, // DstMac, SrcMac
            0x08, 0x00,                                                             // IPv4 Proto
            0x45, 0x00, 0x00, 0x3F, 0x3A, 0x25, 0x00, 0x00, 0x01, 0x11, 0xA3, 0x65, // IPv4 Header
            0xC0, 0xA8, 0x01, 0x01, 0xEF, 0xFF, 0x2A, 0x63,
            0x0D, 0xA3, 0x0D, 0xA2, 0x00, 0x2B, 0xB5, 0xCF,                         // UDP Header
            0x58, 0x31, 0x00, 0x02, 0x00, 0x00, 0x1B, 0x00, 0x44, 0x4C, 0x54, 0x20,
            0x41, 0x72, 0x67, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x20, 0x74, 0x65, 0x73,
            0x74, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x31, 0x2E, 0x00
        };

        [Test]
        public void SplitUdpPacket1()
        {
            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                List<DltTraceLineBase> lines = new();

                lines.AddRange(packetDecoder.DecodePacket(P1a, Time1, 0));
                Assert.That(lines, Is.Empty);

                lines.AddRange(packetDecoder.DecodePacket(P1b, Time1, 0));
                Assert.That(lines, Has.Count.EqualTo(1));
                Assert.That(lines[0].Text, Is.EqualTo("DLT Argument test string.."));
                Assert.That(lines[0].TimeStamp, Is.EqualTo(Time1));
            }
        }

        [Test]
        public void SplitUdpPacket2()
        {
            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                List<DltTraceLineBase> lines = new();

                lines.AddRange(packetDecoder.DecodePacket(P2a, Time1, 0));
                Assert.That(lines, Is.Empty);

                lines.AddRange(packetDecoder.DecodePacket(P2b, Time1, 0));
                Assert.That(lines, Has.Count.EqualTo(1));
                Assert.That(lines[0].Text, Is.EqualTo("DLT Argument test string1."));
                Assert.That(lines[0].TimeStamp, Is.EqualTo(Time1));
            }
        }

        [Test]
        public void InterleavedSplitUdpPacket()
        {
            using (PacketDecoder packetDecoder = new(LinkTypes.LINKTYPE_ETHERNET, DefaultPcapFactory)) {
                List<DltTraceLineBase> lines = new();

                lines.AddRange(packetDecoder.DecodePacket(P1a, Time1, 0));
                Assert.That(lines, Is.Empty);

                lines.AddRange(packetDecoder.DecodePacket(P2a, Time1, 0));
                Assert.That(lines, Is.Empty);

                lines.AddRange(packetDecoder.DecodePacket(P1b, Time2, 0));
                Assert.That(lines, Has.Count.EqualTo(1));
                Assert.That(lines[0].Text, Is.EqualTo("DLT Argument test string.."));
                Assert.That(lines[0].TimeStamp, Is.EqualTo(Time2));  // Time when last part of packet is received

                lines.AddRange(packetDecoder.DecodePacket(P2b, Time2, 0));
                Assert.That(lines, Has.Count.EqualTo(2));
                Assert.That(lines[1].Text, Is.EqualTo("DLT Argument test string1."));
                Assert.That(lines[1].TimeStamp, Is.EqualTo(Time2));  // Time when last part of packet is received
            }
        }
    }
}
