<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ArgErrorBufferTooSmall" xml:space="preserve">
    <value>Buffer of insufficient size</value>
  </data>
  <data name="DomainDecoderInvalidOutputStream" xml:space="preserve">
    <value>OutputStream doesn't support binary</value>
  </data>
  <data name="DomainInputStreamFactoryInvalid" xml:space="preserve">
    <value>Invalid URI {0}, unsupported fields.</value>
    <comment>User provided path or query, which isn't supported</comment>
  </data>
  <data name="DomainInputStreamFactoryUnknown" xml:space="preserve">
    <value>Input URI {0} not unknown</value>
  </data>
  <data name="DomainInputStreamFactoryUnsupported" xml:space="preserve">
    <value>Input URI {0} not supported</value>
  </data>
  <data name="DomainInputStreamNotOpen" xml:space="preserve">
    <value>Cannot connect, input stream has not been opened</value>
  </data>
  <data name="DomainOutputNoOverwrite" xml:space="preserve">
    <value>Not overwriting previously created file {0}.</value>
  </data>
  <data name="DomainOutputNoOverwriteInput" xml:space="preserve">
    <value>Not overwriting the input file {0}.</value>
  </data>
  <data name="DomainOutputStreamFactoryUnknown" xml:space="preserve">
    <value>Output factory type {0} is unknown</value>
  </data>
  <data name="DomainOutputWriterCantWrite" xml:space="preserve">
    <value>OutputWriter can't write to stream</value>
  </data>
  <data name="DomainOutputWriterNotOpen" xml:space="preserve">
    <value>OutputWriter File is not open.</value>
  </data>
  <data name="DomainOutputWriterOpen" xml:space="preserve">
    <value>OutputWriter File is already open.</value>
  </data>
  <data name="DomainPcapBlockCorruption" xml:space="preserve">
    <value>PCAP-NG block corruption found</value>
  </data>
  <data name="DomainPcapInvalidData" xml:space="preserve">
    <value>PCAP file is corrupted (contains invalid data)</value>
  </data>
  <data name="DomainPcapUnknownBlockType" xml:space="preserve">
    <value>Unknown PCAP file format, block {0:x8} found</value>
  </data>
  <data name="DomainPcapUnknownLinkFormat" xml:space="preserve">
    <value>PCAP file format with unknown link type data</value>
  </data>
  <data name="DomainPcapUnknownMagic" xml:space="preserve">
    <value>Unknown PCAP file format</value>
  </data>
  <data name="DomainPcapUnsupportedVersion" xml:space="preserve">
    <value>PCAP file format version {0}.{1} unsupported</value>
  </data>
  <data name="DomainTemplateEmptyVar" xml:space="preserve">
    <value>Empty variable provided</value>
  </data>
  <data name="ErrorAppUnhandledException" xml:space="preserve">
    <value>An internal error has occurred (unhandled exception).</value>
  </data>
  <data name="ErrorDumpBeingGenerated" xml:space="preserve">
    <value>Dumping to: {0}</value>
  </data>
  <data name="FileOpenError_DirectoryNotFound" xml:space="preserve">
    <value>Specified path is invalid {0}</value>
  </data>
  <data name="FileOpenError_EmptyName" xml:space="preserve">
    <value>File name is invalid</value>
  </data>
  <data name="FileOpenError_FileNotFound" xml:space="preserve">
    <value>File not found {0}</value>
  </data>
  <data name="FileOpenError_InvalidFile" xml:space="preserve">
    <value>Couldn't open file {0} ({1}).</value>
  </data>
  <data name="FileOpenError_IOException" xml:space="preserve">
    <value>An I/O Exception occurred opening {0} ({1}).</value>
  </data>
  <data name="FileOpenError_PathTooLong" xml:space="preserve">
    <value>Path length too long {0}</value>
  </data>
  <data name="FileOpenError_Security" xml:space="preserve">
    <value>Insufficient permissions opening {0} ({1})</value>
  </data>
  <data name="FileOpenError_Unauthorized" xml:space="preserve">
    <value>Insufficient access privileges opening {0}</value>
  </data>
  <data name="FilterCheckError_LiveStreams" xml:space="preserve">
    <value>Only one input argument allowed for live streams.</value>
  </data>
  <data name="FilterCheckError_NoStreams" xml:space="preserve">
    <value>No input files specified.</value>
  </data>
  <data name="FilterCheckError_UnknownInput" xml:space="preserve">
    <value>Don't know how to interpret {0}.</value>
  </data>
  <data name="FilterOpenError_ConnectError" xml:space="preserve">
    <value>Couldn't connect to the stream end-point {0}.</value>
  </data>
  <data name="FilterOpenError_Retry" xml:space="preserve">
    <value>Couldn't connect to {0}. Retry {1}...</value>
  </data>
  <data name="FilterOutputError" xml:space="preserve">
    <value>Couldn't create the output {0}. {1}</value>
    <comment>Occurs on exception on create</comment>
  </data>
  <data name="FilterOutputError_UnknownOutput" xml:space="preserve">
    <value>Couldn't create the output {0}. Don't know how to write this file format.</value>
    <comment>Occurs because Automatic can't guess the output format</comment>
  </data>
  <data name="InfraArgOutOfRangeIndex" xml:space="preserve">
    <value>The length and offset would exceed the boundaries of the array/buffer</value>
  </data>
  <data name="InfraArgOutOfRangeNegative" xml:space="preserve">
    <value>may not be negative</value>
  </data>
  <data name="InfraCollectionReadOnly" xml:space="preserve">
    <value>Collection is read only</value>
  </data>
  <data name="InfraDltInvalidFormat" xml:space="preserve">
    <value>Internal Error: Decoding this format is not implemented</value>
  </data>
  <data name="InfraFileNotFound" xml:space="preserve">
    <value>File not found</value>
  </data>
  <data name="InfraFormatHangingIndentException" xml:space="preserve">
    <value>Hanging Indent must be zero or more</value>
  </data>
  <data name="InfraFormatIndentException" xml:space="preserve">
    <value>Indent must be zero or more</value>
  </data>
  <data name="InfraFormatMessageParseException" xml:space="preserve">
    <value>Error parsing string</value>
  </data>
  <data name="InfraFormatWidthException" xml:space="preserve">
    <value>Width should be at least 10 characters including indent</value>
  </data>
  <data name="InfraIoFileInfoInvalidState" xml:space="preserve">
    <value>Class is in an undefined state</value>
  </data>
  <data name="InfraNetTcpStream_NotConnected" xml:space="preserve">
    <value>Not connected</value>
  </data>
  <data name="InfraTaskAlreadyStarted" xml:space="preserve">
    <value>Task is already started</value>
  </data>
  <data name="InfraTcpStreamAlreadyConnected" xml:space="preserve">
    <value>Connection already established</value>
  </data>
  <data name="InfraTcpStreamInvalidHostName" xml:space="preserve">
    <value>Invalid hostname for connection</value>
  </data>
  <data name="InfraUdpReceiverInvalidFamily" xml:space="preserve">
    <value>Address is not of type IPv4</value>
  </data>
  <data name="InfraUdpReceiverInvalidPort" xml:space="preserve">
    <value>Address port {0} is invalid</value>
  </data>
  <data name="InfraUdpReceiverNotMulticast" xml:space="preserve">
    <value>Address {0} is not multicast</value>
  </data>
  <data name="InfraUdpReceiverNotOpen" xml:space="preserve">
    <value>UDP receiver not open</value>
  </data>
  <data name="InfraUdpReceiverNotUnicast" xml:space="preserve">
    <value>Address {0} is not unicast</value>
  </data>
  <data name="InfraUdpReceiverOpen" xml:space="preserve">
    <value>UDP receiver already open</value>
  </data>
  <data name="InfraUriError_EscapeCharacter" xml:space="preserve">
    <value>Error parsing URI parameters, incomplete escape sequence</value>
  </data>
  <data name="InfraUriError_QuoteInMiddle" xml:space="preserve">
    <value>Error parsing URI parameters, quotes must follow entire field</value>
  </data>
  <data name="InfraUriError_QuotesMismatch" xml:space="preserve">
    <value>Error parsing URI parameters, quotes don't match</value>
  </data>
  <data name="InfraUriError_QuotesMultiple" xml:space="preserve">
    <value>Error parsing URI parameters, multiple quotes seen for same field</value>
  </data>
  <data name="InfraUriError_QuotesNotClosed" xml:space="preserve">
    <value>Error parsing URI parameters, quotes not terminated</value>
  </data>
  <data name="OptionInvalidDate" xml:space="preserve">
    <value>Can't interpret date {0} for {1}.</value>
  </data>
  <data name="OptionInvalidDateNotBeforeAfterOrder" xml:space="preserve">
    <value>Nothing to filter, 'not-before' {0:s} must be earlier than 'not-after' {1:s}.</value>
  </data>
  <data name="OptionInvalidFilterType" xml:space="preserve">
    <value>Unknown filter type '{0}'.</value>
  </data>
  <data name="OptionInvalidSplit" xml:space="preserve">
    <value>Option 'split' provided with unrecognized format '{0}'</value>
  </data>
  <data name="OptionInvalidSplitRange" xml:space="preserve">
    <value>Option 'split' value out of range</value>
  </data>
  <data name="OptionInvalidSplitTooSmall" xml:space="preserve">
    <value>The output file size limit cannot be less than 64kB</value>
  </data>
  <data name="OptionsError" xml:space="preserve">
    <value>Problem with the command line.</value>
  </data>
  <data name="OptionSplitParseError" xml:space="preserve">
    <value>Unexpected modifier when parsing the split</value>
  </data>
  <data name="SerialOpenError_AuthorityNotSupported" xml:space="preserve">
    <value>Cannot connect to a remote host with ser:</value>
  </data>
  <data name="SerialOpenError_InvalidBaud" xml:space="preserve">
    <value>Invalid baud rate given for ser:</value>
  </data>
  <data name="SerialOpenError_InvalidDataBits" xml:space="preserve">
    <value>Invalid data bits given for ser:</value>
  </data>
  <data name="SerialOpenError_InvalidHandshake" xml:space="preserve">
    <value>Invalid handshake specified for ser:</value>
  </data>
  <data name="SerialOpenError_InvalidParity" xml:space="preserve">
    <value>Invalid parity specified for ser:</value>
  </data>
  <data name="SerialOpenError_InvalidPort" xml:space="preserve">
    <value>Invalid port given for ser:</value>
  </data>
  <data name="SerialOpenError_InvalidStopBits" xml:space="preserve">
    <value>Invalid parameter for stop bits for ser:</value>
  </data>
  <data name="SerialOpenError_InvalidUri" xml:space="preserve">
    <value>Invalid URI specifier for ser:port,baud,data,parity,stop[,hshake]</value>
  </data>
  <data name="TcpOpenError_InvalidHostName" xml:space="preserve">
    <value>Invalid host name: {0}</value>
  </data>
  <data name="VersionDltDump" xml:space="preserve">
    <value>DltDump Version: {0}</value>
  </data>
  <data name="VersionDltDumpCopyright" xml:space="preserve">
    <value>DltDump Version: {0}, {1}</value>
  </data>
  <data name="VersionNetRuntime" xml:space="preserve">
    <value>  Runtime: {0}</value>
  </data>
  <data name="VersionTraceReader" xml:space="preserve">
    <value>  TraceReader: {0}</value>
  </data>
  <data name="VersionTraceReaderDlt" xml:space="preserve">
    <value>  TraceReader.Dlt: {0}</value>
  </data>
</root>